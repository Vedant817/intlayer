```bash
.
├── locales
│   ├── en
│   │  ├── common.json
│   │  └── about.json
│   ├── fr
│   │  ├── common.json
│   │  └── about.json
│   └── es
│      ├── common.json
│      └── about.json
└── src
    ├── i18n.ts
    ├── middleware.ts
    ├── app
    │   └── [locale]
    │       ├── layout.tsx
    │       └── about
    │           └── page.tsx
    └── components
        ├── ClientComponentExample.tsx
        └── ServerComponent.tsx
```

#### Setup and Loading Content

As mentioned previously, you must optimize how each JSON file is imported into your code.
How the library handles content loading is important.

```tsx fileName="src/i18n.ts"
import { getRequestConfig } from 'next-intl/server';
import { notFound } from 'next/navigation';

export const locales = ['en', 'fr', 'es'] as const;
export const defaultLocale = 'en' as const;

async function loadMessages(locale: string) {
  // Load only the namespaces your layout/pages need
  const [common, about] = await Promise.all([
    import(`../locales/${locale}/common.json`).then((m) => m.default),
    import(`../locales/${locale}/about.json`).then((m) => m.default),
  ]);

  return { common, about } as const;
}

export default getRequestConfig(async ({ locale }) => {
  if (!locales.includes(locale as any)) notFound();

  return {
    messages: await loadMessages(locale),
  };
});
```

```tsx fileName="src/app/[locale]/layout.tsx"
import type { ReactNode } from 'react';
import { locales } from '@/i18n';
import {
  getLocaleDirection,
  unstable_setRequestLocale,
} from 'next-intl/server';

export function generateStaticParams() {
  return locales.map((locale) => ({ locale }));
}

export default function LocaleLayout({
  children,
  params,
}: {
  children: ReactNode;
  params: Promise<{ locale: string }>;
}) {
  const { locale } = await params;

  // Set the active request locale for this server render (RSC)
  unstable_setRequestLocale(locale);

  const dir = getLocaleDirection(locale);

  return (
    <html lang={locale} dir={dir}>
      <body>{children}</body>
    </html>
  );
}
```

```tsx fileName="src/app/[locale]/about/page.tsx"
import { getTranslations, getMessages, getFormatter } from 'next-intl/server';
import { NextIntlClientProvider } from 'next-intl';
import pick from 'lodash/pick';
import ServerComponent from '@/components/ServerComponent';
import ClientComponentExample from '@/components/ClientComponentExample';

export default async function AboutPage({
  params,
}: {
  params: Promise<{ locale: string }>;
}) {
  const { locale } = await params;

  // Messages are loaded server-side. Push only what's needed to the client.
  const messages = await getMessages();
  const clientMessages = pick(messages, ['common', 'about']);

  // Strictly server-side translations/formatting
  const tAbout = await getTranslations('about');
  const tCounter = await getTranslations('about.counter');
  const format = await getFormatter();

  const initialFormattedCount = format.number(0);

  return (
    <NextIntlClientProvider locale={locale} messages={clientMessages}>
      <main>
        <h1>{tAbout('title')}</h1>
        <ClientComponentExample />
        <ServerComponent
          formattedCount={initialFormattedCount}
          label={tCounter('label')}
          increment={tCounter('increment')}
        />
      </main>
    </NextIntlClientProvider>
  );
}
```

### Usage in a client component

Let's take an example of a client component rendering a counter.

**Translations (shape reused; load them into next-intl messages as you prefer)**

```json fileName="locales/en/about.json"
{
  "counter": {
    "label": "Counter",
    "increment": "Increment"
  }
}
```

```json fileName="locales/fr/about.json"
{
  "counter": {
    "label": "Compteur",
    "increment": "Incrémenter"
  }
}
```

**Client component**

```tsx fileName="src/components/ClientComponentExample.tsx"
'use client';

import React, { useState } from 'react';
import { useTranslations, useFormatter } from 'next-intl';

const ClientComponentExample = () => {
  // Scope directly to the nested object
  const t = useTranslations('about.counter');
  const format = useFormatter();
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>{format.number(count)}</p>
      <button
        aria-label={t('label')}
        onClick={() => setCount((count) => count + 1)}
      >
        {t('increment')}
      </button>
    </div>
  );
};
```

> Don't forget to add "about" message on the page client message
> (only include the namespaces your client actually needs).

### Usage in a server component

We will take the case of a UI component. This component is a server component, and should be able to be inserted as a child of a client component. (page (server component) -> client component -> server component). As this component can be inserted as a child of a client component, it cannot be async.

```tsx fileName="src/components/ServerComponent.tsx"
type ServerComponentProps = {
  count: number;
  t: (key: string) => string;
  formatter: Intl.NumberFormat;
};

const ServerComponent = ({ t, count, formatter }: ServerComponentProps) => {
  const formatted = formatter.format(count);

  return (
    <div>
      <p>{formatted}</p>
      <button aria-label={t('label')}>{t('increment')}</button>
    </div>
  );
};
```

> As the server component cannot be async, you need to pass the translations and formatter function as props.
>
> In your page / layout:
>
> - `import { getTranslations, getFormatter } from "next-intl/server";`
> - `const t = await getTranslations("about.counter");`
> - `const formatter = await getFormatter().then((formatter) => formatter.number());`

```tsx fileName="src/app/[locale]/about/layout.tsx"
import type { Metadata } from 'next';
import { locales, defaultLocale } from '@/i18n';
import { getTranslations } from 'next-intl/server';

function localizedPath(locale: string, path: string) {
  return locale === defaultLocale ? path : '/' + locale + path;
}

export async function generateMetadata({
  params,
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const { locale } = params;
  const t = await getTranslations({ locale, namespace: 'about' });

  const url = '/about';
  const languages = Object.fromEntries(
    locales.map((locale) => [locale, localizedPath(locale, url)])
  );

  return {
    title: t('title'),
    description: t('description'),
    alternates: {
      canonical: localizedPath(locale, url),
      languages: { ...languages, 'x-default': url },
    },
  };
}

// ... Rest of the page code
```

```tsx fileName="src/app/sitemap.ts"
import type { MetadataRoute } from 'next';
import { locales, defaultLocale } from '@/i18n';

const origin = 'https://example.com';

const formatterLocalizedPath = (locale: string, path: string) =>
  locale === defaultLocale ? origin + path : origin + '/' + locale + path;

export default function sitemap(): MetadataRoute.Sitemap {
  const aboutLanguages = Object.fromEntries(
    locales.map((l) => [l, formatterLocalizedPath(l, '/about')])
  );

  return [
    {
      url: formatterLocalizedPath(defaultLocale, '/about'),
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.7,
      alternates: { languages: aboutLanguages },
    },
  ];
}
```

```tsx fileName="src/app/robots.ts"
import type { MetadataRoute } from 'next';
import { locales, defaultLocale } from '@/i18n';

const origin = 'https://example.com';
const withAllLocales = (path: string) => [
  path,
  ...locales
    .filter((locale) => locale !== defaultLocale)
    .map((locale) => '/' + locale + path),
];

export default function robots(): MetadataRoute.Robots {
  const disallow = [
    ...withAllLocales('/dashboard'),
    ...withAllLocales('/admin'),
  ];

  return {
    rules: { userAgent: '*', allow: ['/'], disallow },
    host: origin,
    sitemap: origin + '/sitemap.xml',
  };
}
```

### Middleware for locale routing

Add a middleware to handle locale detection and routing:

```ts fileName="src/middleware.ts"
import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from '@/i18n';

export default createMiddleware({
  locales: [...locales],
  defaultLocale,
  localeDetection: true,
});

export const config = {
  // Skip API, Next internals and static assets
  matcher: ['/((?!api|_next|.*\\..*).*)'],
};
```

### Best practices

- **Set html `lang` and `dir`**: In `src/app/[locale]/layout.tsx`, compute `dir` via `getLocaleDirection(locale)` and set `<html lang={locale} dir={dir}>`.
- **Split messages by namespace**: Organize JSON per locale and namespace (e.g., `common.json`, `about.json`).
- **Minimize client payload**: On pages, send only required namespaces to `NextIntlClientProvider` (e.g., `pick(messages, ['common', 'about'])`).
- **Prefer static pages**: Export `export const dynamic = 'force-static'` and generate static params for all `locales`.
- **Synchronous server components**: Keep server components sync by passing precomputed strings (translated labels, formatted numbers) rather than async calls or non-serializable functions.
